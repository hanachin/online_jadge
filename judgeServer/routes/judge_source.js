// Generated by CoffeeScript 1.6.2
var DateFormat, compareSource, compileSource, executeError, executeSource, inputExecute, kondoMethod, makeDir, noinputExecute, pulloutNumber, removeDir, replaceEqualsign, replaceFullsizeChar, replaceSource, saveResult, sendMsg, skipTable, toUpper, writeSource, writeTestcase;

DateFormat = (function() {
  var _digits;

  _digits = function(digits, n) {
    var pad;

    if (("" + n).length >= digits) {
      return "" + n;
    } else {
      pad = digits - ("" + n).length;
      return "" + ((new Array(pad + 1)).join("0")) + n;
    }
  };

  function DateFormat() {
    this.date = new Date();
  }

  DateFormat.prototype.toString = function() {
    var d, hour, min, month, sec, year;

    year = this.date.getFullYear();
    month = _digits(2, this.date.getMonth() + 1);
    d = _digits(2, this.date.getDate());
    hour = _digits(2, this.date.getHours());
    min = _digits(2, this.date.getMinutes());
    sec = _digits(2, this.date.getSeconds());
    return "" + year + "/" + month + "/" + d + " " + hour + ":" + min + ":" + sec;
  };

  DateFormat.format = function() {
    return "" + (new DateFormat);
  };

  return DateFormat;

})();

exports.main = function(req, res, dataBase) {
  var answerTable, async, child_process, correcterTable, fs, seq, submitQueueTable, submitTable, testcaseTable;

  fs = require('fs');
  child_process = require('child_process');
  async = require('async');
  seq = dataBase.seq;
  submitTable = dataBase.submitTable;
  answerTable = dataBase.answerTable;
  testcaseTable = dataBase.testcaseTable;
  correcterTable = dataBase.correcterTable;
  submitQueueTable = dataBase.submitQueueTable;
  req.username = req.query.username;
  req.questionNo = req.query.questionNo;
  req.source = req.query.source;
  req.argTestcase = [];
  req.argStdout = [];
  req.argAnswer = [];
  req.compile_error = "";
  req.stderr = "";
  req.result = "";
  req.dir = "" + req.socket._idleStart + "-" + req.username;
  req.dir_path = "" + __dirname + "/../public/source/" + req.dir;
  return async.series([
    function(callBack) {
      console.log("user 1st ---------------------------------------");
      console.log("replaceSource - " + (DateFormat.format()));
      console.log("workerID -> " + process.env["WORKER_PORT"]);
      return replaceSource(req, req.source, callBack);
    }, function(callBack) {
      console.log("makeDir - " + (DateFormat.format()));
      return makeDir(req.dir_path, fs.mkdir, callBack);
    }, function(callBack) {
      console.log("writeSource - " + (DateFormat.format()));
      return writeSource(req.questionNo, req.source, req.dir_path, fs.writeFile, callBack);
    }, function(callBack) {
      console.log("writeTestcase - " + (DateFormat.format()));
      return writeTestcase(req, req.questionNo, req.dir_path, answerTable, fs.writeFileSync, callBack);
    }, function(callBack) {
      console.log("compileSource - " + (DateFormat.format()));
      return compileSource(req, req.questionNo, req.dir_path, child_process.exec, callBack);
    }, function(callBack) {
      console.log("executeSource - " + (DateFormat.format()));
      return executeSource(req, req.questionNo, req.dir_path, child_process.exec, callBack);
    }, function(callBack) {
      console.log("compareSource - " + (DateFormat.format()));
      return compareSource(req, callBack);
    }, function(callBack) {
      console.log("saveResult - " + (DateFormat.format()));
      return saveResult(req, req.questionNo, req.username, req.source, submitTable, correcterTable, callBack);
    }, function(callBack) {
      console.log("removeDir - " + (DateFormat.format()));
      return removeDir(req.questionNo, req.dir_path, child_process.exec, callBack);
    }, function(callBack) {
      console.log("sendMsg - " + (DateFormat.format()));
      return sendMsg(req, res, callBack);
    }
  ], function(err, result) {
    if (err) {
      throw err;
      res.send(500, err);
    }
    process.env["WORKER_STATE"] = false;
    console.log("request end - " + (DateFormat.format()));
    return console.log("end user 1st ---------------------------------------");
  });
};

replaceSource = function(req, source, callBack) {
  req.source = source.replace(/\r\n/g, '\n');
  return callBack(null, 2);
};

makeDir = function(path, mkdir, callBack) {
  return mkdir(path, '0777', function(err) {
    if (err) {
      console.log("" + path + " make_dir err -> " + err);
      return;
    }
    return callBack(null, 3);
  });
};

writeSource = function(questionNo, source, path, fswrite, callBack) {
  return fswrite("" + path + "/" + questionNo + ".c", source, function(err) {
    if (err) {
      console.log("" + path + " fswrite error -> " + err);
      return;
    }
    return callBack(null, 4);
  });
};

writeTestcase = function(req, questionNo, path, answerTable, fswrite, callBack) {
  return answerTable.findAll({
    where: {
      questionNo: questionNo
    },
    order: 'id'
  }).success(function(columns) {
    var column, i, testcase_path, _i, _len;

    if ((columns[0] != null)) {
      for (i = _i = 0, _len = columns.length; _i < _len; i = ++_i) {
        column = columns[i];
        if (column.testcase !== '') {
          testcase_path = "" + path + "/" + questionNo + i + ".txt";
          req.argTestcase[i] = "" + questionNo + i + ".txt";
          fswrite(testcase_path, column.testcase);
        }
        req.argAnswer[i] = column.answer;
      }
    }
    return callBack(null, 5);
  });
};

compileSource = function(req, questionNo, path, exec, callBack) {
  return exec("gcc -Wall -o " + path + "/" + questionNo + ".out " + path + "/" + questionNo + ".c", function(err, stdout, stderr) {
    var tmp;

    if (err) {
      req.result = 'Compile Error';
      err = new String(err);
      tmp = new RegExp(req.dir_path, 'g');
      req.compile_error = err.replace(tmp, '');
      console.log("Compile Error -> " + err);
    }
    return callBack(null, 6);
  });
};

executeSource = function(req, questionNo, path, exec, callBack) {
  if (req.result !== '') {
    callBack(null, 7);
    return;
  }
  if (0 < req.argTestcase.length) {
    inputExecute(req, questionNo, path, exec, callBack, 0);
    return;
  }
  return noinputExecute(req, questionNo, path, exec, callBack, 0);
};

noinputExecute = function(req, questionNo, path, exec, callBack, num) {
  var exePath;

  exePath = "" + path + "/" + questionNo + ".out";
  return exec(exePath, {
    timeout: 3000,
    maxBuffer: 65536
  }, function(err, stdout, stderr) {
    var tmp;

    if (err) {
      err = new String(err);
      tmp = new RegExp(req.dir_path, 'g');
      req.stderr = err.replace(tmp, '');
      req.result = executeError(num, err);
      callBack(null, 7);
      return;
    }
    req.argStdout[num] = stdout.replace(/\r\n$/, '');
    return callBack(null, 7);
  });
};

inputExecute = function(req, questionNo, path, exec, callBack, num) {
  var cmd, exePath, testPath;

  if (num >= req.argTestcase.length) {
    callBack(null, 7);
    return;
  }
  exePath = "" + path + "/" + questionNo + ".out";
  testPath = "" + path + "/" + req.argTestcase[num];
  cmd = "" + exePath + " < " + testPath;
  return exec(cmd, {
    timeout: 3000,
    maxBuffer: 65536
  }, function(err, stdout, stderr) {
    var tmp;

    if (err) {
      err = new String(err);
      tmp = new RegExp(req.dir_path, 'g');
      req.stderr = err.replace(tmp, '');
      req.result = executeError(num, err);
      callBack(null, 7);
      return;
    }
    req.argStdout[num] = stdout.replace(/\r?\n$/, '');
    return inputExecute(req, questionNo, path, exec, callBack, num + 1);
  });
};

executeError = function(num, err) {
  var signal;

  signal = err.toString();
  if (0 < signal.indexOf('maxBuffer')) {
    return 'Segmentation Fault';
  }
  if (0 < signal.indexOf('Command')) {
    return 'Time Limit Exceeded';
  }
  return "不明なエラーです";
};

compareSource = function(req, callBack) {
  var answer, answers, i, kondo_check, result, stdouts, _i, _len;

  stdouts = req.argStdout;
  answers = req.argAnswer;
  result = req.result;
  console.log("実行結果 + 解答");
  console.log(stdouts);
  console.log(answers);
  if (result !== '') {
    console.log("" + req.ip + " result err : " + result);
  } else {
    for (i = _i = 0, _len = answers.length; _i < _len; i = ++_i) {
      answer = answers[i];
      if (stdout[i] !== answer) {
        kondo_check = kondoMethod(stdout[i], answer);
        console.log("kondo_check: " + kondo_check);
        if (kondo_check === true) {
          req.result = "Accept";
        } else {
          req.result = "Wrong Answer";
          break;
        }
      } else {
        req.result = "Accept";
      }
    }
  }
  return callBack(null, 8);
};

saveResult = function(req, questionNo, username, source, submitTable, correcterTable, callBack) {
  var insert_obj, saveData;

  insert_obj = {
    userID: username,
    questionNo: questionNo,
    source: source,
    time: DateFormat.format(),
    result: req.result
  };
  saveData = submitTable.build(insert_obj);
  return saveData.save().success(function() {
    console.log('DB save success');
    return callBack(null, 9);
  });
};

removeDir = function(questionNo, path, exec, callBack) {
  var cmd;

  cmd = "rm -rf " + path + "/";
  exec(cmd, {}, function(err, stdout, stderr) {
    if (err) {
      return console.log("rm error -> " + err);
    }
  });
  return callBack(null, 10);
};

sendMsg = function(req, res, callBack) {
  var obj;

  obj = {
    cmperr: req.compile_error,
    stderr: req.stderr,
    result: req.result
  };
  res.send('200', obj);
  return callBack(null, 12);
};

kondoMethod = function(stdout, answer) {
  stdout = replaceFullsizeChar(stdout);
  answer = replaceFullsizeChar(answer);
  if (stdout === answer) {
    return true;
  }
  stdout = toUpper(stdout);
  answer = toUpper(answer);
  if (stdout === answer) {
    return true;
  }
  stdout = replaceEqualsign(stdout);
  if (stdout === answer) {
    return true;
  }
  stdout = skipTable(stdout);
  if (stdout === answer) {
    return true;
  }
  stdout = pulloutNumber(stdout);
  answer = pulloutNumber(answer);
  if (stdout === '' || answer === '') {
    return false;
  }
  if (stdout === answer) {
    return true;
  }
  return false;
};

replaceFullsizeChar = function(string) {
  var translation;

  return translation = string.replace(/[！-～]/g, function(str) {
    return String.fromCharCode(str.charCodeAt(0) - 0xFEE0);
  });
};

toUpper = function(string) {
  var translation;

  return translation = string.toUpperCase();
};

replaceEqualsign = function(string) {
  var translation;

  return translation = string.replace(/:/g, '=');
};

skipTable = function(string) {
  var translation;

  return translation = string.replace(/[ ]+/g, '');
};

pulloutNumber = function(string) {
  var c, decimal1, decimal2, i, number, _i, _len, _ref, _ref1;

  number = '';
  for (i = _i = 0, _len = string.length; _i < _len; i = ++_i) {
    c = string[i];
    if (('0' <= c && c <= '9')) {
      number += c;
    }
    if (c === '.') {
      decimal1 = (_ref = string[i + 1]) != null ? _ref : '0';
      decimal2 = (_ref1 = string[i + 2]) != null ? _ref1 : '0';
      number += decimal1 + decimal2;
      break;
    }
  }
  return number;
};
